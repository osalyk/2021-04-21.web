{{top "Remote Persistent Memory"}}

<p>
We assume you already know what Persistent Memory (or PMem for short) is and hopefully you have learned many possible ways of benefiting from using it in your applications. In this example we want to introduce to you a basic way of accessing the very same Persistent Memory but when it is installed in a remote system. Remote Persistent Memory (or RPMem for short) is a way of doing this by making use of the Remote Direct Memory Access (RDMA) network.

<p>
You may ask why you even bother doing so? Why your application simply cannot run on the remote system where the already mentioned Persistent Memory is installed instead of on yet another system? Why complicate the solution?

<p>
There are many possible answers to all of these questions:
<ul>
    <li>scalability</li>
    <li>fail-safety</li>
    <li>redundancy</li>
    <li>migrability</li>
    <li>configurability</li>
    <li>...</li>
</ul>

<p>
Long story short, RPMem is a way how to fit Persistent Memory into modern cloud-based applications.

<p>
Before we go any further, you have to understand that despite PMem and RPMem both are making use of the same Persistent Memory, RPMem accesses Persistent Memory via the network. Network technologies develop rapidly but they are still a few orders of magnitude slower comparing to accessing the local memory directly. This makes PMem and RPMem ideal for different applications. If you want to learn more about the performance achievable with RPMem please follow the link: <a href="https://pmem.io/rpma/reports/index.html" target="_blank">Performance Reports</a>.

<p>
This example is an introduction to RPMem. We will guide you briefly through setting up all required hardware and software components and verifying whether the connection works properly. Having that, we will show you how to access Persistent Memory on a remote system using the librpma library (where RPMA stands for Remote Persistent Memory Access, makes sense right?).

<p>
After completing this example you will know:
<ul>
    <li>what is RPMem and what it is good for</li>
    <li>how RPMem is different comparing to PMem</li>
    <li>what hardware and software components are required to start using RPMem</li>
    <li>how to verify whether the RDMA network works properly</li>
    <li>how to use librpma API to:
        <ul>
            <li>establish a connection,</li>
            <li>prepare memory for remote manipulation,</li>
            <li>manipulate memory on the remote system,</li>
            <li>assure persistency of stores to the remote system.</li>
        </ul>
    </li>
</ul>

<p>
Step-by-step you will:
<ul>
    <li>test the connection on the basic level using ping</li>
    <li>test the connection RDMA capabilities using rping</li>
    <li>review an application focusing on establishing a connection</li>
    <li>review an application reading remote system's memory and writing it back in the persistent manner.</li>
</ul>

{{step "Connectivity check"}}

<p>
In order to have a real RDMA network you have to have:
<ul>
    <li>two machines both equipped with RDMA-capable network adapters connected to each other,</li>
    <li>libibverbs and librdmacm libraries installed in both systems (or the rdma-core package containing both of them).</li>
</ul>

<p>
Alternatively, for development purposes, you can use a software-emulated RDMA network interface (SoftRoCE) which requires:
<ul>
    <li>one machine with a regular Ethernet network adapter,</li>
    <li>the above listed libraries and</li>
    <li>the 'rdma_rxe' kernel module loaded.</li>
</ul>

<p>
All used network interfaces should be configured, up and running with an IP address assigned.

<p>
In this step, we will check the basic Ethernet network connectivity using the ping command
(see the <a href="https://linux.die.net/man/8/ping" target="_blank">ping(8) manual</a> for details).

{{edit "run_test_ping.sh"}}

{{run "./run_test_ping.sh"}}

<p>
In this step we will check the RDMA CM connection with the RDMA ping-pong test using the rping command
(provided by the librdmacm-utils package).

<p>
The rping(1) command establishes a reliable RDMA connection between two nodes using librdmacm
and optionally performs RDMA transfers between the nodes, then disconnects. When rping works,
we know that the RDMA connection is correctly configured and works well.

{{edit "run_test_rping.sh"}}

{{run "./run_test_rping.sh"}}

{{step "Establishing a connection"}}

<p>
XXX
- introduce the librpma library
- maybe put here the schematic showing where librpma fits into the Linux RDMA-capable stack
- describe that the following program focuses solely on establishing a connection

{{edit "simple_client.c" "simple_server.c" "connection.h" "connection.c" "CMakeLists.txt" "build_simple.sh"}}

{{build "./build_simple.sh"}}

{{edit "run_simple.sh"}}

{{run "./run_simple.sh"}}

{{step "Remote Persistent Memory access"}}

<p>
XXX
- introduce used rpma_read/write/flush() operations and
- describe their role in achieving remote persistency
- describe what the example does
- refer the "connection.h" "connection.c" files are taken from the previous step

{{edit "client.c" "server.c" "connection.h" "build_main.sh"}}

{{build "./build_main.sh"}}

{{edit "run_main.sh"}}

{{run "./run_main.sh"}}

{{summary}}

<p>
During this session, you have:
<ul>
    <li>checked basic network connectivity</li>
    <li>checked whether the network is RDMA-capable</li>
    <li>established a connection using the librpma library</li>
    <li>read and wrote back RPMem's content in the persistent way</li>
</ul>

<p>
Takeaways:
<ul>
    <li>Remote Persistent Memory (RPMem) is a way of accessing Persistent Memory when it is installed in a remote system</li>
    <li>RPMem leverages RDMA capabilities to achieve e.g.:
        <ul>
            <li>zero-copy read of the contents of RPMem</li>
            <li>single-sided persistency of the PMem's contents on the remote system</li>
        </ul>
    </li>
    <li>RPMem is a way to seamlessly incorporate PMem into modern cloud architectures</li>
    <li>The librpma library is a ready to use simple API incarnating RPMem principles</li>
</ul>

<p>
If you want to learn more:
<ul>
    <li><a href="https://github.com/pmem/rpma" target="_blank">https://github.com/pmem/rpma</a> - where librpma is forged
        <ul>
            <li>We especially recommend getting familiar with <a href="https://github.com/pmem/rpma/tree/master/examples" target="_blank">examples</a> that allows you to learn about other supported use-cases.</li>
        </ul>
    </li>
    <li><a href="https://pmem.io/rpma/" target="_blank">https://pmem.io/rpma/</a> - where you can find the librpma library manuals, configuration guidelines and performance reports</li>
    <li>It may be also useful to read our whitepaper: <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/persistent-memory-replication-over-traditional-rdma-part-1-understanding-remote-persistent.html" target="_blank">Persistent Memory Replication Over Traditional RDMA</a>
        <ul>
            <li><b>Note</b> it describes RPMem in the context of the librpmem library (do not confuse with librpma) which is a completely different story.</li>
        </ul>
    </li>
</ul>

<p>
Thank you very much for your attention!

<p>
Yours sincerely<br/>
RPMem PMDK Squad

{{bottom}}
